# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008–2018, Scrapy developers
# This file is distributed under the same license as the Scrapy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Scrapy 1.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-09-25 09:29+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../topics/selectors.rst:5
msgid "Selectors"
msgstr "セレクタ"

#: ../../topics/selectors.rst:7
msgid ""
"When you're scraping web pages, the most common task you need to perform "
"is to extract data from the HTML source. There are several libraries "
"available to achieve this:"
msgstr ""
"Webページをスクレイピングするときに必要な最も一般的な作業は、"
"HTMLソースからデータを抽出することです。"
"これを達成するために利用可能ないくつかのライブラリがあります。"

#: ../../topics/selectors.rst:11
msgid ""
"`BeautifulSoup`_ is a very popular web scraping library among Python "
"programmers which constructs a Python object based on the structure of "
"the HTML code and also deals with bad markup reasonably well, but it has "
"one drawback: it's slow."
msgstr ""
"`BeautifulSoup`_ は、Pythonプログラマーの間で非常に人気のあるWebスクレイピングライブラリです。"
"HTMLコードの構造に基づいてPythonオブジェクトを作成し、また、不適切なマークアップを適切に処理しますが、"
"遅いという欠点があります。"

#: ../../topics/selectors.rst:16
msgid ""
"`lxml`_ is an XML parsing library (which also parses HTML) with a "
"pythonic API based on `ElementTree`_. (lxml is not part of the Python "
"standard library.)"
msgstr ""
"`lxml`_ は、 `ElementTree`_ をベースにしたPythonicなAPIを備えたXML解析ライブラリ（HTMLも解析できます）です。"
"lxmlはPython標準ライブラリの一部ではありません。"

#: ../../topics/selectors.rst:20
msgid ""
"Scrapy comes with its own mechanism for extracting data. They're called "
"selectors because they \"select\" certain parts of the HTML document "
"specified either by `XPath`_ or `CSS`_ expressions."
msgstr ""
"Scrapyには、データを抽出するための独自のメカニズムが付属しています。"
"HTMLドキュメントの特定の部分を `XPath`_ 式または `CSS`_ 式で「選択」するため、これらはセレクタと呼ばれます。"

#: ../../topics/selectors.rst:24
msgid ""
"`XPath`_ is a language for selecting nodes in XML documents, which can "
"also be used with HTML. `CSS`_ is a language for applying styles to HTML "
"documents. It defines selectors to associate those styles with specific "
"HTML elements."
msgstr ""
"`XPath`_ はXML文書内のノードを選択するための言語ですが、HTMLでも使用できます。"
" `CSS`_ はHTMLドキュメントにスタイルを適用するための言語です。"
"スタイルを特定のHTML要素に関連付けるためのセレクタを定義します。"

#: ../../topics/selectors.rst:28
msgid ""
"Scrapy selectors are built over the `lxml`_ library, which means they're "
"very similar in speed and parsing accuracy."
msgstr ""
"Scrapyのセレクタは、 `lxml`_ ライブラリ上に構築されていますので、"
"速度と解析の正確さが非常によく似ています。"

#: ../../topics/selectors.rst:31
msgid ""
"This page explains how selectors work and describes their API which is "
"very small and simple, unlike the `lxml`_ API which is much bigger "
"because the `lxml`_ library can be used for many other tasks, besides "
"selecting markup documents."
msgstr ""
"このページでは、セレクタがどのように動作するかを説明します。"
"また、 `lxml`_ ライブラリは他の多くのタスクに使用できるため、"
"巨大な `lxml`_ APIとは異なり、非常に小さくシンプルなAPIについて説明します。"

#: ../../topics/selectors.rst:36
msgid ""
"For a complete reference of the selectors API see :ref:`Selector "
"reference <topics-selectors-ref>`"
msgstr ""
"セレクタAPIの詳細なリファレンスについては、 :ref:`Selector reference <topics-selectors-ref>` を参照してください。"

#: ../../topics/selectors.rst:48 ../../topics/selectors.rst:83
msgid "Using selectors"
msgstr "セレクタの使用"

#: ../../topics/selectors.rst:51
msgid "Constructing selectors"
msgstr "セレクタの構築"

#: ../../topics/selectors.rst:55
msgid ""
"Scrapy selectors are instances of :class:`~scrapy.selector.Selector` "
"class constructed by passing **text** or "
":class:`~scrapy.http.TextResponse` object. It automatically chooses the "
"best parsing rules (XML vs HTML) based on input type::"
msgstr ""
"Scrapyのセレクタは、 **テキスト** または :class:`~scrapy.http.TextResponse` オブジェクトを"
"渡すことによって構築された :class:`~scrapy.selector.Selector` クラスのインスタンスです。"
"入力タイプに基づいて最適な解析ルール（XMLとHTML）を自動的に選択します。"

#: ../../topics/selectors.rst:63
msgid "Constructing from text::"
msgstr "テキストから構築する："

#: ../../topics/selectors.rst:69
msgid "Constructing from response::"
msgstr "Responseから構築する："

#: ../../topics/selectors.rst:75
msgid ""
"For convenience, response objects expose a selector on `.selector` "
"attribute, it's totally OK to use this shortcut when possible::"
msgstr ""
"利便性のため、responseオブジェクトは `.selector` 属性にセレクタを公開しています。"
"可能であればこのショートカットを使用しても問題ありません。"

#: ../../topics/selectors.rst:85
msgid ""
"To explain how to use the selectors we'll use the `Scrapy shell` (which "
"provides interactive testing) and an example page located in the Scrapy "
"documentation server:"
msgstr ""
"セレクタの使用方法を説明するために、 `Scrapyシェル` （これは対話式のテストを提供します）と"
"Scrapy文書サーバーにあるサンプルページを使用します。"

#: ../../topics/selectors.rst:89
msgid "https://doc.scrapy.org/en/latest/_static/selectors-sample1.html"
msgstr ""

#: ../../topics/selectors.rst:93
msgid "Here's its HTML code:"
msgstr "そのHTMLコードは次のとおりです。"

#: ../../topics/selectors.rst:100
msgid "First, let's open the shell::"
msgstr "まず、シェルを開きましょう。"

#: ../../topics/selectors.rst:104
msgid ""
"Then, after the shell loads, you'll have the response available as "
"``response`` shell variable, and its attached selector in "
"``response.selector`` attribute."
msgstr ""
"シェルがロードされた後に、レスポンスとして利用可能な ``response`` シェル変数と、"
"セレクタとして利用可能な ``response.selector`` 属性を使うことができます。"

#: ../../topics/selectors.rst:107
msgid ""
"Since we're dealing with HTML, the selector will automatically use an "
"HTML parser."
msgstr ""
"HTMLを扱うので、セレクタは自動的にHTMLパーサーになります。"

#: ../../topics/selectors.rst:111
msgid ""
"So, by looking at the :ref:`HTML code <topics-selectors-htmlcode>` of "
"that page, let's construct an XPath for selecting the text inside the "
"title tag::"
msgstr ""
"そのページの :ref:`HTMLコード <topics-selectors-htmlcode>` を見て、"
"titleタグ内のテキストを選択するためのXPathを作成しましょう。"

#: ../../topics/selectors.rst:117
msgid ""
"Querying responses using XPath and CSS is so common that responses "
"include two convenience shortcuts: ``response.xpath()`` and "
"``response.css()``::"
msgstr ""
"XPathやCSSを使用してレスポンスを問い合わせるのはとても一般的なので、"
"responseには ``response.xpath()`` と ``response.css()`` の"
"2つの便利なショートカットが含まれています。"

#: ../../topics/selectors.rst:125
msgid ""
"As you can see, ``.xpath()`` and ``.css()`` methods return a "
":class:`~scrapy.selector.SelectorList` instance, which is a list of new "
"selectors. This API can be used for quickly selecting nested data::"
msgstr ""
"ご覧のように、 ``.xpath()`` および ``.css()`` メソッドは、"
"新しいセレクタのリストである :class:`~scrapy.selector.SelectorList` インスタンスを返します。"
"このAPIはネストしたデータを素早く選択するために使用できます。"

#: ../../topics/selectors.rst:136
msgid ""
"To actually extract the textual data, you must call the selector "
"``.extract()`` method, as follows::"
msgstr ""
"実際のテキストデータを抽出するには、次のようにselectorの ``.extract()`` メソッドを呼び出す必要があります。"

#: ../../topics/selectors.rst:142
msgid ""
"If you want to extract only first matched element, you can call the "
"selector ``.extract_first()``"
msgstr ""
"最初に一致した要素だけを抽出したい場合は、selectorの ``.extract_first()`` を呼び出すことができます。"

#: ../../topics/selectors.rst:147
msgid "It returns ``None`` if no element was found:"
msgstr "要素が見つからなかった場合は ``None`` を返します。"

#: ../../topics/selectors.rst:152
msgid ""
"A default return value can be provided as an argument, to be used instead"
" of ``None``:"
msgstr ""
"デフォルトの戻り値を引数として渡し、 ``None`` の代わりに使用することもできます。"

#: ../../topics/selectors.rst:157
msgid ""
"Notice that CSS selectors can select text or attribute nodes using CSS3 "
"pseudo-elements::"
msgstr ""
"CSSセレクタの場合は、CSS3の疑似要素を使用してテキストまたは属性ノードを"
"選択できることに注意してください。"

#: ../../topics/selectors.rst:163
msgid "Now we're going to get the base URL and some image links::"
msgstr "ベースURLと画像リンクを取得します。"

#: ../../topics/selectors.rst:202
msgid "Nesting selectors"
msgstr "ネストされたセレクタ"

#: ../../topics/selectors.rst:204
msgid ""
"The selection methods (``.xpath()`` or ``.css()``) return a list of "
"selectors of the same type, so you can call the selection methods for "
"those selectors too. Here's an example::"
msgstr ""
"選択メソッド（ ``.xpath()`` または ``.css()`` ）は同じタイプのセレクタのリストを返すので、"
"それらのセレクタでさらに選択メソッドを呼び出すことができます。次に例を示します。"

#: ../../topics/selectors.rst:227
msgid "Using selectors with regular expressions"
msgstr "セレクタで正規表現を使う"

#: ../../topics/selectors.rst:229
msgid ""
":class:`~scrapy.selector.Selector` also has a ``.re()`` method for "
"extracting data using regular expressions. However, unlike using "
"``.xpath()`` or ``.css()`` methods, ``.re()`` returns a list of unicode "
"strings. So you can't construct nested ``.re()`` calls."
msgstr ""
":class:`~scrapy.selector.Selector` には、正規表現を使用してデータを抽出するための"
" ``.re()`` メソッドもあります。ただし、 ``.xpath()`` や ``.css()`` メソッドを使用するのとは異なり、"
" ``.re()`` はUnicode文字列のリストを返します。そのため、 ``.re()`` 呼び出しを入れ子にすることはできません。"

#: ../../topics/selectors.rst:234
msgid ""
"Here's an example used to extract image names from the :ref:`HTML code "
"<topics-selectors-htmlcode>` above::"
msgstr ""
"上記の :ref:`HTMLコード <topics-selectors-htmlcode>` から"
"イメージ名を抽出するのに使用される例は、次のとおりです。"

#: ../../topics/selectors.rst:244
msgid ""
"There's an additional helper reciprocating ``.extract_first()`` for "
"``.re()``, named ``.re_first()``. Use it to extract just the first "
"matching string::"
msgstr ""
"``.re()`` のための ``.extract_first()`` に対応する追加のヘルパーがあり、"
" ``.re_first()`` という名前です。最初に一致した文字列だけを抽出するのに使用します。"

#: ../../topics/selectors.rst:253
msgid "Working with relative XPaths"
msgstr "XPathを相対的に操作する"

#: ../../topics/selectors.rst:255
msgid ""
"Keep in mind that if you are nesting selectors and use an XPath that "
"starts with ``/``, that XPath will be absolute to the document and not "
"relative to the ``Selector`` you're calling it from."
msgstr ""
"セレクタを入れ子にして ``/`` で始まるXPathを使用する場合、"
"そのXPathはドキュメントに対して絶対的なものであり、"
"呼び出し元の ``Selector`` に対して相対的なものではないことに留意してください。"

#: ../../topics/selectors.rst:259
msgid ""
"For example, suppose you want to extract all ``<p>`` elements inside "
"``<div>`` elements. First, you would get all ``<div>`` elements::"
msgstr ""
"たとえば、 ``<div>`` 要素内のすべての ``<p>`` 要素を抽出するとします。"
"まず、すべての ``<div>`` 要素を取得します。"

#: ../../topics/selectors.rst:264
msgid ""
"At first, you may be tempted to use the following approach, which is "
"wrong, as it actually extracts all ``<p>`` elements from the document, "
"not only those inside ``<div>`` elements::"
msgstr ""
"最初は以下のようなアプローチを取りがちですが、これは、"
"実際には ``<div>`` 要素の内部だけでなく、すべての ``<p>`` 要素を文書から抽出するため、間違っています。"

#: ../../topics/selectors.rst:271
msgid ""
"This is the proper way to do it (note the dot prefixing the ``.//p`` "
"XPath)::"
msgstr "こちらは適切な方法です（XPath ``.//p`` にドットプレフィックスがあります）。"

#: ../../topics/selectors.rst:276
msgid "Another common case would be to extract all direct ``<p>`` children::"
msgstr ""
"もうひとつの一般的なケースは、直接の子である ``<p>`` を抽出することです。"

#: ../../topics/selectors.rst:281
msgid ""
"For more details about relative XPaths see the `Location Paths`_ section "
"in the XPath specification."
msgstr ""
"相対XPathの詳細については、XPath仕様の `Location Paths`_ セクションを参照してください。"

#: ../../topics/selectors.rst:289
msgid "Variables in XPath expressions"
msgstr "XPath式の中の変数"

#: ../../topics/selectors.rst:291
msgid ""
"XPath allows you to reference variables in your XPath expressions, using "
"the ``$somevariable`` syntax. This is somewhat similar to parameterized "
"queries or prepared statements in the SQL world where you replace some "
"arguments in your queries with placeholders like ``?``, which are then "
"substituted with values passed with the query."
msgstr ""
"XPathでは、 ``$somevariable`` 構文を使用して、XPath式内の変数を参照できます。 "
"これは、クエリの引数の一部を ``?`` などのプレースホルダに置き換えたSQLの世界での"
"パラメータ化クエリやプリペアドステートメントとやや似ています。"
"これらはクエリに渡された値に置き換えられます。"

#: ../../topics/selectors.rst:297
msgid ""
"Here's an example to match an element based on its \"id\" attribute "
"value, without hard-coding it (that was shown previously)::"
msgstr ""
"次の例は、ハードコーディングをせずに、その「id」属性値に基づいて要素を照合します（以前に示したものです）。"

#: ../../topics/selectors.rst:304
msgid ""
"Here's another example, to find the \"id\" attribute of a ``<div>`` tag "
"containing five ``<a>`` children (here we pass the value ``5`` as an "
"integer)::"
msgstr ""
"別の例として、5つの ``<a>`` の子を含む ``<div>`` タグの「id」属性を見つけるものを示します"
"（ここでは値 ``5`` を整数として渡します）。"

#: ../../topics/selectors.rst:310
msgid ""
"All variable references must have a binding value when calling "
"``.xpath()`` (otherwise you'll get a ``ValueError: XPath error:`` "
"exception). This is done by passing as many named arguments as necessary."
msgstr ""
"すべての変数参照は、 ``.xpath()`` を呼び出すときにバインド値を持つ必要があります"
"（そうでなければ、 ``ValueError: XPath error:`` 例外が発生します）。"
"これは、必要な数の名前付き引数を渡すことによって行われます。"

#: ../../topics/selectors.rst:314
msgid ""
"`parsel`_, the library powering Scrapy selectors, has more details and "
"examples on `XPath variables`_."
msgstr ""
"Scrapyのセレクタを強力にしているライブラリ `parsel`_ には、"
" `XPath変数`_ に関する詳細と例があります。"

#: ../../topics/selectors.rst:321
msgid "Using EXSLT extensions"
msgstr "EXSLT拡張機能を使う"

#: ../../topics/selectors.rst:323
msgid ""
"Being built atop `lxml`_, Scrapy selectors also support some `EXSLT`_ "
"extensions and come with these pre-registered namespaces to use in XPath "
"expressions:"
msgstr ""
"Scrapyのセレクタは `lxml`_ の上に構築されているために、いくつかの `EXSLT`_ 拡張もサポートしており、"
"XPath式で使用するために予約されたネームスペースがあります。"

#: ../../topics/selectors.rst:328
msgid "prefix"
msgstr "プレフィクス"

#: ../../topics/selectors.rst:328
msgid "namespace"
msgstr "ネームスペース"

#: ../../topics/selectors.rst:328
msgid "usage"
msgstr "使用法"

#: ../../topics/selectors.rst:330
msgid "`regular expressions`_"
msgstr ""

#: ../../topics/selectors.rst:331
msgid "`set manipulation`_"
msgstr ""

#: ../../topics/selectors.rst:335
msgid "Regular expressions"
msgstr "正規表現"

#: ../../topics/selectors.rst:337
msgid ""
"The ``test()`` function, for example, can prove quite useful when XPath's"
" ``starts-with()`` or ``contains()`` are not sufficient."
msgstr ""
"たとえば、 ``test()`` 関数は、XPathの ``starts-with()`` や ``contains()`` だけでは"
"不十分な場合に非常に便利です。"

#: ../../topics/selectors.rst:340
msgid ""
"Example selecting links in list item with a \"class\" attribute ending "
"with a digit::"
msgstr ""
"数字で終わる「class」属性を持つリスト項目内のリンクを選択する例："

#: ../../topics/selectors.rst:361
msgid ""
"C library ``libxslt`` doesn't natively support EXSLT regular expressions "
"so `lxml`_'s implementation uses hooks to Python's ``re`` module. Thus, "
"using regexp functions in your XPath expressions may add a small "
"performance penalty."
msgstr ""
"Cライブラリ ``libxslt`` はEXSLT正規表現をネイティブサポートしていないため、"
" `lxml`_ の実装はPythonの ``re`` モジュールへのフックを使用します。"
"そのため、XPath式で正規表現関数を使用すると、パフォーマンスが若干低下する可能性があります。"

#: ../../topics/selectors.rst:367
msgid "Set operations"
msgstr "集合演算"

#: ../../topics/selectors.rst:369
msgid ""
"These can be handy for excluding parts of a document tree before "
"extracting text elements for example."
msgstr ""
"これらは、例えばテキスト要素を抽出する前に文書ツリーの一部を除外するのに便利です。"

#: ../../topics/selectors.rst:372
msgid ""
"Example extracting microdata (sample content taken from "
"http://schema.org/Product) with groups of itemscopes and corresponding "
"itemprops::"
msgstr ""
"itemscopeとそれに対応するitempropのグループを含むmicrodataの抽出例"
"（ http://schema.org/Product から取得したサンプルコンテンツ）："

#: ../../topics/selectors.rst:457
msgid ""
"Here we first iterate over ``itemscope`` elements, and for each one, we "
"look for all ``itemprops`` elements and exclude those that are themselves"
" inside another ``itemscope``."
msgstr ""
"ここではまず ``itemscope`` 要素を反復し、それぞれに対して ``itemprops`` 要素をすべて探し、"
"別の ``itemscope`` 内にあるものを除外します。"

#: ../../topics/selectors.rst:467
msgid "Some XPath tips"
msgstr "XPathヒント集"

#: ../../topics/selectors.rst:469
msgid ""
"Here are some tips that you may find useful when using XPath with Scrapy "
"selectors, based on `this post from ScrapingHub's blog`_. If you are not "
"much familiar with XPath yet, you may want to take a look first at this "
"`XPath tutorial`_."
msgstr ""
"`ScrapingHubブログのこの投稿`_ に基づいた、"
"ScrapyセレクタでXPathを使うときに役立つヒントをいくつか示します。"
"XPathにまだ慣れていない場合は、まずこの `XPathチュートリアル`_ を見てください。"

#: ../../topics/selectors.rst:480
msgid "Using text nodes in a condition"
msgstr "条件内でのテキストノードの使用"

#: ../../topics/selectors.rst:482
msgid ""
"When you need to use the text content as argument to an `XPath string "
"function`_, avoid using ``.//text()`` and use just ``.`` instead."
msgstr ""
"`XPath文字列関数`_ の引数としてテキストコンテンツを使う必要がある場合は、"
" ``.//text()`` を使用せず、代わりに ``.`` を使用してください。"

#: ../../topics/selectors.rst:485
msgid ""
"This is because the expression ``.//text()`` yields a collection of text "
"elements -- a *node-set*. And when a node-set is converted to a string, "
"which happens when it is passed as argument to a string function like "
"``contains()`` or ``starts-with()``, it results in the text for the first"
" element only."
msgstr ""
"これは、式 ``.//text()`` がテキスト要素の集合、つまり *ノードセット* を生成するためです。"
"そして、ノードセットが ``contains()`` や ``starts-with()`` のような文字列関数に引数として渡され"
"文字列に変換されるとき、最初の要素のみのテキストを返します。"

#: ../../topics/selectors.rst:489 ../../topics/selectors.rst:527
msgid "Example::"
msgstr "例："

#: ../../topics/selectors.rst:494
msgid "Converting a *node-set* to string::"
msgstr "ノードセットを文字列に変換します。"

#: ../../topics/selectors.rst:501
msgid ""
"A *node* converted to a string, however, puts together the text of itself"
" plus of all its descendants::"
msgstr ""
"ただし、文字列に変換された *ノード* は、それ自体のテキストとそのすべての子孫のテキストをまとめたものです。"

#: ../../topics/selectors.rst:508
msgid "So, using the ``.//text()`` node-set won't select anything in this case::"
msgstr "したがって、 ``.//text()`` ノードセットを使用しても、この場合は何も選択されません。"

#: ../../topics/selectors.rst:513
msgid "But using the ``.`` to mean the node, works::"
msgstr "しかし、ノードを意味する ``.`` を使用すると、うまくいきます。"

#: ../../topics/selectors.rst:521
msgid "Beware of the difference between //node[1] and (//node)[1]"
msgstr "//node[1] と (//node)[1] の違いに注意"

#: ../../topics/selectors.rst:523
msgid ""
"``//node[1]`` selects all the nodes occurring first under their "
"respective parents."
msgstr ""
"``//node[1]`` は、それぞれの親の下に最初に出現するすべてのノードを選択します。"

#: ../../topics/selectors.rst:525
msgid ""
"``(//node)[1]`` selects all the nodes in the document, and then gets only"
" the first of them."
msgstr ""
"``(//node)[1]`` はドキュメント内のすべてのノードを選択し、それらのうち最初のノードだけを取得します。"

#: ../../topics/selectors.rst:543
msgid "This gets all first ``<li>``  elements under whatever it is its parent::"
msgstr "こちらは、親であるものが何であれ、最初の ``<li>`` 要素をすべて取得します。"

#: ../../topics/selectors.rst:548
msgid "And this gets the first ``<li>``  element in the whole document::"
msgstr "そしてこちらは、文書全体の最初の ``<li>`` 要素を取得します。"

#: ../../topics/selectors.rst:553
msgid "This gets all first ``<li>``  elements under an ``<ul>``  parent::"
msgstr "こちらは、親が ``<ul>`` である最初の ``<li>`` 要素をすべて取得します。"

#: ../../topics/selectors.rst:558
msgid ""
"And this gets the first ``<li>``  element under an ``<ul>``  parent in "
"the whole document::"
msgstr "そしてこちらは、文書全体の最初の、親が ``<ul>`` である ``<li>`` 要素を取得します。"

#: ../../topics/selectors.rst:564
msgid "When querying by class, consider using CSS"
msgstr "クラスで検索するときに、CSSの使用を検討する"

#: ../../topics/selectors.rst:566
msgid ""
"Because an element can contain multiple CSS classes, the XPath way to "
"select elements by class is the rather verbose::"
msgstr ""
"要素には複数のCSSクラスを含めることができるので、"
"クラスで要素を選択するXPathの方法はかなり冗長です。"

#: ../../topics/selectors.rst:571
msgid ""
"If you use ``@class='someclass'`` you may end up missing elements that "
"have other classes, and if you just use ``contains(@class, 'someclass')``"
" to make up for that you may end up with more elements that you want, if "
"they have a different class name that shares the string ``someclass``."
msgstr ""
"``@class='someclass'`` を使用すると、要素が他のクラスも持っていると取りこぼすことがあります。"
"そのために ``contains(@class, 'someclass')`` を使用しても、"
"文字列 ``someclass`` を含む異なるクラス名がある場合は、そちらも取得してしまいます。"

#: ../../topics/selectors.rst:576
msgid ""
"As it turns out, Scrapy selectors allow you to chain selectors, so most "
"of the time you can just select by class using CSS and then switch to "
"XPath when needed::"
msgstr ""
"結局のところ、Scrapyセレクタを使うとセレクタをチェーンさせることができるので、"
"ほとんどの場合はCSSを使用してクラスで選択し、必要に応じてXPathに切り替えることができます。"

#: ../../topics/selectors.rst:584
msgid ""
"This is cleaner than using the verbose XPath trick shown above. Just "
"remember to use the ``.`` in the XPath expressions that will follow."
msgstr ""
"これは、上記の冗長なXPathのトリックを使用するよりもクリーンです。"
"続くXPath式で ``.`` を使用することを忘れないでください。"

#: ../../topics/selectors.rst:591
msgid "Built-in Selectors reference"
msgstr "組み込みのセレクタリファレンス"

#: ../../topics/selectors.rst:597
msgid "Selector objects"
msgstr "Selectorオブジェクト"

#: ../../topics/selectors.rst:601
msgid ""
"An instance of :class:`Selector` is a wrapper over response to select "
"certain parts of its content."
msgstr ""
":class:`Selector` インスタンスは、コンテンツの特定の部分を選択するための、"
"レスポンスに対するラッパーです。"

#: ../../topics/selectors.rst:604
msgid ""
"``response`` is an :class:`~scrapy.http.HtmlResponse` or an "
":class:`~scrapy.http.XmlResponse` object that will be used for selecting "
"and extracting data."
msgstr ""
"``response`` は、データの選択および抽出に使用される :class:`~scrapy.http.HtmlResponse` "
"または :class:`~scrapy.http.XmlResponse` オブジェクトです。"

#: ../../topics/selectors.rst:608
msgid ""
"``text`` is a unicode string or utf-8 encoded text for cases when a "
"``response`` isn't available. Using ``text`` and ``response`` together is"
" undefined behavior."
msgstr ""
"``text`` は、 ``response`` が有効でない場合のUnicode文字列またはUTF-8でエンコードされたテキストです。"
" ``text`` と ``response`` を一緒に使用することは未定義の動作です。"

#: ../../topics/selectors.rst:612
msgid ""
"``type`` defines the selector type, it can be ``\"html\"``, ``\"xml\"`` "
"or ``None`` (default)."
msgstr ""
"``type`` はセレクタタイプを定義します。 "
" ``\"html\"``, ``\"xml\"``, ``None`` （デフォルト）のいずれかです。"

#: ../../topics/selectors.rst:614
msgid ""
"If ``type`` is ``None``, the selector automatically chooses the best type"
" based on ``response`` type (see below), or defaults to ``\"html\"`` in "
"case it is used together with ``text``."
msgstr ""
"``type`` が ``None`` の場合、セレクタは自動的に ``response`` の種類（下記参照）に基づいて最適なタイプを選択します。"
" ``text`` と共に使用される場合はデフォルトの ``\"html\"`` になります。"

#: ../../topics/selectors.rst:618
msgid ""
"If ``type`` is ``None`` and a ``response`` is passed, the selector type "
"is inferred from the response type as follows:"
msgstr ""
"``type`` が ``None`` で ``response`` が渡された場合、"
"セレクタタイプは次のようにレスポンスタイプから推測されます。"

#: ../../topics/selectors.rst:621
msgid "``\"html\"`` for :class:`~scrapy.http.HtmlResponse` type"
msgstr ":class:`~scrapy.http.HtmlResponse` タイプの場合は ``\"html\"``"

#: ../../topics/selectors.rst:622
msgid "``\"xml\"`` for :class:`~scrapy.http.XmlResponse` type"
msgstr ":class:`~scrapy.http.XmlResponse` タイプの場合は ``\"xml\"``"

#: ../../topics/selectors.rst:623
msgid "``\"html\"`` for anything else"
msgstr "その他の場合は ``\"html\"``"

#: ../../topics/selectors.rst:625
msgid ""
"Otherwise, if ``type`` is set, the selector type will be forced and no "
"detection will occur."
msgstr ""
"``type`` が設定されている場合は、セレクタタイプは強制され、検出は行われません。"

#: ../../topics/selectors.rst:630
msgid ""
"Find nodes matching the xpath ``query`` and return the result as a "
":class:`SelectorList` instance with all elements flattened. List elements"
" implement :class:`Selector` interface too."
msgstr ""
"XPathクエリ ``query`` に一致するノードを見つけ、その結果をすべての要素がフラット化された"
" :class:`SelectorList` インスタンスとして返します。"
"リストの要素は :class:`Selector` インターフェースも実装しています。"

#: ../../topics/selectors.rst:634
msgid "``query`` is a string containing the XPATH query to apply."
msgstr "``query`` は適用するXPathクエリの文字列です。"

#: ../../topics/selectors.rst:638
msgid "For convenience, this method can be called as ``response.xpath()``"
msgstr "利便性のため、このメソッドは ``response.xpath()`` でも呼ぶことができます。"

#: ../../topics/selectors.rst:642
msgid "Apply the given CSS selector and return a :class:`SelectorList` instance."
msgstr "与えられたCSSセレクタを適用して :class:`SelectorList` インスタンスを返します。"

#: ../../topics/selectors.rst:644
msgid "``query`` is a string containing the CSS selector to apply."
msgstr "``query`` は適用するCSSセレクタの文字列です。"

#: ../../topics/selectors.rst:646
msgid ""
"In the background, CSS queries are translated into XPath queries using "
"`cssselect`_ library and run ``.xpath()`` method."
msgstr ""
"バックグラウンドでは、CSSクエリは `cssselect`_ ライブラリを使用して"
"XPathクエリに変換され、 ``.xpath()`` メソッドが実行されます。"

#: ../../topics/selectors.rst:651
msgid "For convenience this method can be called as ``response.css()``"
msgstr "利便性のため、このメソッドは ``response.css()`` でも呼ぶことができます。"

#: ../../topics/selectors.rst:655
msgid ""
"Serialize and return the matched nodes as a list of unicode strings. "
"Percent encoded content is unquoted."
msgstr ""
"一致したノードをシリアライズし、Unicode文字列のリストとして返します。"
"パーセントでエンコードされたコンテンツはアンクォートされます。"

#: ../../topics/selectors.rst:660
msgid ""
"Apply the given regex and return a list of unicode strings with the "
"matches."
msgstr ""
"与えられた正規表現を適用して、一致したUnicode文字列のリストを返します。"

#: ../../topics/selectors.rst:663
msgid ""
"``regex`` can be either a compiled regular expression or a string which "
"will be compiled to a regular expression using ``re.compile(regex)``"
msgstr ""
"``regex`` はコンパイルされた正規表現か、"
" ``re.compile(regex)`` を使って正規表現にコンパイルされる文字列のどちらかです。"

#: ../../topics/selectors.rst:668
msgid ""
"Note that ``re()`` and ``re_first()`` both decode HTML entities (except "
"``&lt;`` and ``&amp;``)."
msgstr ""
"``re()`` と ``re_first()`` はどちらもHTMLエンティティをデコードすることに"
"注意してください（ ``&lt;`` と ``&amp;`` を除く）。"

#: ../../topics/selectors.rst:672
msgid ""
"Register the given namespace to be used in this :class:`Selector`. "
"Without registering namespaces you can't select or extract data from non-"
"standard namespaces. See examples below."
msgstr ""
"この :class:`Selector` で使用されるネームスペースを登録します。"
"ネームスペースを登録しないと、非標準のネームスペースからデータを選択または抽出することはできません。"
"下記の例を参照してください。"

#: ../../topics/selectors.rst:678
msgid ""
"Remove all namespaces, allowing to traverse the document using namespace-"
"less xpaths. See example below."
msgstr ""
"すべてのネームスペースを削除し、ネームスペースのないXPathを使用して"
"文書をトラバースできるようにします。下記の例を参照してください。"

#: ../../topics/selectors.rst:683
msgid ""
"Returns ``True`` if there is any real content selected or ``False`` "
"otherwise.  In other words, the boolean value of a :class:`Selector` is "
"given by the contents it selects."
msgstr ""
"実際のコンテンツが選択されていれば ``True`` を、そうでなければ ``False`` を返します。"
"つまり、 :class:`Selector` のこのブール値は、選択した内容によって決まります。"

#: ../../topics/selectors.rst:689
msgid "SelectorList objects"
msgstr "SelectorListオブジェクト"

#: ../../topics/selectors.rst:693
msgid ""
"The :class:`SelectorList` class is a subclass of the builtin ``list`` "
"class, which provides a few additional methods."
msgstr ""
":class:`SelectorList` クラスは組み込みの ``list`` クラスのサブクラスで、"
"いくつかの追加メソッドが提供されています。"

#: ../../topics/selectors.rst:698
msgid ""
"Call the ``.xpath()`` method for each element in this list and return "
"their results flattened as another :class:`SelectorList`."
msgstr ""
"このリストの各要素に対して ``.xpath()`` メソッドを呼び出し、"
"それらの結果を別の :class:`SelectorList` としてフラット化して返します。"

#: ../../topics/selectors.rst:701
msgid "``query`` is the same argument as the one in :meth:`Selector.xpath`"
msgstr "``query`` は :meth:`Selector.xpath` のものと同じ引数です。"

#: ../../topics/selectors.rst:705
msgid ""
"Call the ``.css()`` method for each element in this list and return their"
" results flattened as another :class:`SelectorList`."
msgstr ""
"このリストの各要素に対して ``.css()`` メソッドを呼び出し、"
"それらの結果を別の :class:`SelectorList` としてフラット化して返します。"

#: ../../topics/selectors.rst:708
msgid "``query`` is the same argument as the one in :meth:`Selector.css`"
msgstr "``query`` は :meth:`Selector.css` のものと同じ引数です。"

#: ../../topics/selectors.rst:712
msgid ""
"Call the ``.extract()`` method for each element in this list and return "
"their results flattened, as a list of unicode strings."
msgstr ""
"このリストの各要素に対して ``.extract()`` メソッドを呼び出し、"
"それらの結果をUnicode文字列のリストとしてフラット化して返します。"

#: ../../topics/selectors.rst:717
msgid ""
"Call the ``.re()`` method for each element in this list and return their "
"results flattened, as a list of unicode strings."
msgstr ""
"このリストの各要素に対して ``.re()`` メソッドを呼び出し、"
"それらの結果をUnicode文字列のリストとしてフラット化して返します。"

#: ../../topics/selectors.rst:722
msgid "Selector examples on HTML response"
msgstr "HTMLレスポンスに関するセレクタの例"

#: ../../topics/selectors.rst:724
msgid ""
"Here's a couple of :class:`Selector` examples to illustrate several "
"concepts. In all cases, we assume there is already a :class:`Selector` "
"instantiated with a :class:`~scrapy.http.HtmlResponse` object like this::"
msgstr ""
"いくつかの概念を説明するために :class:`Selector` の例を紹介します。"
"すべての例において、以下のような :class:`~scrapy.http.HtmlResponse` オブジェクトで"
"インスタンス化された :class:`Selector` がすでにあると仮定します。"

#: ../../topics/selectors.rst:730
msgid ""
"Select all ``<h1>`` elements from an HTML response body, returning a list"
" of :class:`Selector` objects (ie. a :class:`SelectorList` object)::"
msgstr ""
"HTMLのレスポンスボディからすべての ``<h1>`` 要素を選択し、"
" :class:`Selector` オブジェクトのリスト（つまり :class:`SelectorList` オブジェクト）を返します。"

#: ../../topics/selectors.rst:735
msgid ""
"Extract the text of all ``<h1>`` elements from an HTML response body, "
"returning a list of unicode strings::"
msgstr ""
"HTMLのレスポンスボディからすべての ``<h1>`` 要素のテキストを抽出し、Unicode文字列のリストを返します。"

#: ../../topics/selectors.rst:741
msgid "Iterate over all ``<p>`` tags and print their class attribute::"
msgstr "すべての ``<p>`` タグを繰り返し処理し、それらのclass属性を出力します。"

#: ../../topics/selectors.rst:747
msgid "Selector examples on XML response"
msgstr "XMLレスポンスに関するセレクタの例"

#: ../../topics/selectors.rst:749
msgid ""
"Here's a couple of examples to illustrate several concepts. In both cases"
" we assume there is already a :class:`Selector` instantiated with an "
":class:`~scrapy.http.XmlResponse` object like this::"
msgstr "いくつかの概念を説明するための例を示します。どちらの場合も、"
"以下のような :class:`~scrapy.http.XmlResponse` オブジェクトで"
"インスタンス化された :class:`Selector` がすでにあると仮定します。"

#: ../../topics/selectors.rst:755
msgid ""
"Select all ``<product>`` elements from an XML response body, returning a "
"list of :class:`Selector` objects (ie. a :class:`SelectorList` object)::"
msgstr ""
"XMLのレスポンスボディからすべての ``<product>`` 要素を選択し、"
" :class:`Selector` オブジェクトのリスト（つまり :class:`SelectorList` オブジェクト）を返します。"

#: ../../topics/selectors.rst:760
msgid ""
"Extract all prices from a `Google Base XML feed`_ which requires "
"registering a namespace::"
msgstr ""
"ネームスペースを登録する必要がある `Google Base XML feed`_ フィードからすべての価格を抽出します。"

#: ../../topics/selectors.rst:769
msgid "Removing namespaces"
msgstr "ネームスペースを削除する"

#: ../../topics/selectors.rst:771
msgid ""
"When dealing with scraping projects, it is often quite convenient to get "
"rid of namespaces altogether and just work with element names, to write "
"more simple/convenient XPaths. You can use the "
":meth:`Selector.remove_namespaces` method for that."
msgstr ""
"スクレイピングプロジェクトを扱うときに、ネームスペースを完全に取り除くと、"
"要素名を扱うだけで、より単純で便利なXPathを書くことが非常に便になります。"
"これには :meth:`Selector.remove_namespaces` メソッドを使用できます。"

#: ../../topics/selectors.rst:776
msgid "Let's show an example that illustrates this with GitHub blog atom feed."
msgstr "GitHubブログのAtomフィードでこれを説明する例を見てみましょう。"

#: ../../topics/selectors.rst:780
msgid "First, we open the shell with the url we want to scrape::"
msgstr "まず、抽出したいURLでシェルを開きます。"

#: ../../topics/selectors.rst:786
msgid ""
"Once in the shell we can try selecting all ``<link>`` objects and see "
"that it doesn't work (because the Atom XML namespace is obfuscating those"
" nodes)::"
msgstr ""
"シェルに入ったら、すべての ``<link>`` オブジェクトを選択しても機能しないことを確認します"
"（Atom XMLネームスペースがこれらのノードを見づらくしているため）。"

#: ../../topics/selectors.rst:792
msgid ""
"But once we call the :meth:`Selector.remove_namespaces` method, all nodes"
" can be accessed directly by their names::"
msgstr ""
"しかし、 :meth:`Selector.remove_namespaces` メソッドを呼び出すと、"
"すべてのノードにそれらの名前で直接アクセスできます。"

#: ../../topics/selectors.rst:801
msgid ""
"If you wonder why the namespace removal procedure isn't always called by "
"default instead of having to call it manually, this is because of two "
"reasons, which, in order of relevance, are:"
msgstr ""
"ネームスペースの削除を手動で呼び出すのではなく、デフォルトで常に呼び出されない理由は、以下の2つです。"

#: ../../topics/selectors.rst:805
msgid ""
"Removing namespaces requires to iterate and modify all nodes in the "
"document, which is a reasonably expensive operation to perform for all "
"documents crawled by Scrapy"
msgstr ""
"ネームスペースを削除するには、ドキュメント内のすべてのノードを反復して変更する必要があります。"
"これは、Scrapyによってクロールされたすべてのドキュメントに対して実行するには、かなり手間のかかる操作です。"

#: ../../topics/selectors.rst:809
msgid ""
"There could be some cases where using namespaces is actually required, in"
" case some element names clash between namespaces. These cases are very "
"rare though."
msgstr ""
"非常にまれなケースですが、いくつかの要素名がネームスペースの間で衝突する場合のために、"
"ネームスペースの使用が実際に必要とされる場合があるかもしれません。"
